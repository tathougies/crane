{-# LANGUAGE OverloadedStrings #-}
module Web.Crane.Response where

import Web.Crane.Types

import Blaze.ByteString.Builder

import Control.Monad.Reader

import qualified Data.CaseInsensitive as CI
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Text.Encoding as TE
import Data.Text (Text)
import Data.Monoid
import Data.ByteString (ByteString)

import Network.HTTP.Types

import Text.Blaze
import Text.Blaze.Renderer.Utf8 (renderMarkup)

instance Monoid (CraneResponseBuilder app master) where
    mempty = CraneResponseBuilder (\_ res -> res)
    mappend (CraneResponseBuilder a) (CraneResponseBuilder b) =
        CraneResponseBuilder (\s -> b s . a s)

status :: Status -> CraneResponseBuilder app master
status statusCode = CraneResponseBuilder (\_ res -> res { crStatusCode = statusCode })

responseBodyLBS :: LBS.ByteString -> CraneResponseBuilder app master
responseBodyLBS body = CraneResponseBuilder (\_ res -> res { crResponseBody = CraneResponseBodyBuilder . fromLazyByteString $ body })

htmlResponseBody :: LBS.ByteString -> CraneResponseBuilder app master
htmlResponseBody body = header "Content-type" "text/html" <>
                        responseBodyLBS body

htmlMarkupBody :: Markup -> CraneResponseBuilder app master
htmlMarkupBody markup = htmlResponseBody (renderMarkup markup)

header :: ByteString -> ByteString -> CraneResponseBuilder app master
header name value = CraneResponseBuilder (\_ res -> res { crHeaders = (CI.mk name, value):crHeaders res })

redirect :: Text -> CraneResponseBuilder app master
redirect uri = status seeOther303 <>
               header "Location" (TE.encodeUtf8 uri)


-- | This lets AfterResponseActions (usually generated by middlewares) modify the response before it is sent out
modifyResponse :: CraneResponseBuilder app master -> AfterResponseActions app master
modifyResponse modifier  = AfterResponseActions $
                           \response -> do request <- ask
                                           return (runResponseBuilder modifier request response)